{"pages":[{"title":"小屋","text":"记录喜悦、感悟和焦虑。 最重要的是，我希望有本日记来回顾下，看看自己走了多远。 如果你碰巧出现在了这个互联网世界的小角落，不妨停下来打个招呼。","link":"/about/index.html"}],"posts":[{"title":"CS144 笔记","text":"开个坑，记录下 CS144 的学习过程。 CS144 的官网：https://cs144.github.io/ 环境准备 注：CS144 用 MacOS 是不行的，因为 C++ 网络编程中用到的库具有平台依赖性，一些头文件只有 Linux 才有，从官网下载下来项目在 MacOS 上 cmake 过不了，我尝试去下载或新建，最后还是差一个头文件没补全… 在 Linux 上自然不用多说，在 Windows 上的话，我的解决方案是 Clion + wsl2。 Writing webget第一个 test 是实现一个通过 get 请求获取 web 资源的程序，即对应着讲义前文的 Networking by hand。 根据 Hints 描述以及平时的工作经验来讲，大致来讲就是通过套接字（Socket）与要访问的主机建立连接（connect），然后不断的读取从服务器端传过来的报文。因此写下了如下代码： 123456shared_ptr&lt;TCPSocket&gt; socket = make_shared&lt;TCPSocket&gt;();shared_ptr&lt;Address&gt; address = make_shared&lt;Address&gt;(host, path);socket-&gt;connect(*address);while (!socket-&gt;eof()) { cerr &lt;&lt; socket-&gt;read();} 上述代码当然是跑不通的，它暴露出了我对计算机网络的认识相当的粗浅，存在的问题有： Address根据注释，是IP/DNS相关的类，「地址」应该由位置（IP）+ 访问协议（HTTP）组成，我莫名其妙传了个资源路径 path 。 建立连接之后是发起请求的时候，这个时候通过指定 HTTP 的请求方式以及资源路径。 根据讲义的 HINTS ，发送完请求之后应当「ending outgoing bytestream」并且最后要「close」。 cerr是错误输出流，cout才是标准输出流。 因此正确的代码如下： 1234567891011void get_URL(const string &amp;host, const string &amp;path) { shared_ptr&lt;TCPSocket&gt; socket = make_shared&lt;TCPSocket&gt;(); shared_ptr&lt;Address&gt; address = make_shared&lt;Address&gt;(host, &quot;http&quot;); socket-&gt;connect(*address); socket-&gt;write(&quot;GET &quot; + path + &quot; HTTP/1.1\\r\\nHost: &quot; + host + &quot;\\r\\n\\r\\n&quot;); socket-&gt;shutdown(SHUT_WR); while (!socket-&gt;eof()) { count &lt;&lt; socket-&gt;read(); } socket-&gt;close();} Lab0","link":"/2021/01/23/CS144-%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CS144","slug":"CS144","link":"/tags/CS144/"}],"categories":[{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}